function [t,xp_avg_ADE,xp_var_ADE,xp_skew_ADE,xp_kur_ADE,BTCs,D_coef,x,C] = model_ADE_Dt(time_sim,mean_xp_sim,var_xp_sim,diameter,dxups)


% Declare global variables
global global_time_sim
global global_D_coef
global global_mean_vp_sim


% Would you like to divide the time domain 
% for avoiding memory errors if t and x are huge vectors? *****************
flag_div = 1;                                                              % 1: yes. 0: no.


% Convert to column vector the input variables ****************************
time_sim    = time_sim(:);
mean_xp_sim = mean_xp_sim(:);
var_xp_sim  = var_xp_sim(:);


% Mean particles velocity *************************************************
for i=1:length(mean_xp_sim)
   if i==1
       mean_vp_sim(i,1) = (mean_xp_sim(2)-mean_xp_sim(1))/(time_sim(2)-time_sim(1));
   elseif i==length(mean_xp_sim)
       mean_vp_sim(i,1) = (mean_xp_sim(end)-mean_xp_sim(end-1))/(time_sim(end)-time_sim(end-1));
   else
       mean_vp_sim(i,1) = (mean_xp_sim(i+1)-mean_xp_sim(i-1))/(time_sim(i+1)-time_sim(i-1));
   end
end


% Diffusion coefficient as a function of the time *************************
for i=1:length(mean_xp_sim)
   if i==1
       D_coef(i,1) = 0.5*(var_xp_sim(2)-var_xp_sim(1))/(time_sim(2)-time_sim(1));
   elseif i==length(mean_xp_sim)
       D_coef(i,1) = 0.5*(var_xp_sim(end)-var_xp_sim(end-1))/(time_sim(end)-time_sim(end-1));
   else
       D_coef(i,1) = 0.5*(var_xp_sim(i+1)-var_xp_sim(i-1))/(time_sim(i+1)-time_sim(i-1));
   end
end


% Define global variables for giving to the diffusion solver
global_time_sim    = time_sim;
global_D_coef      = D_coef;
global_mean_vp_sim = mean_vp_sim;


% Space and time discretization *******************************************
scale_dx = 100;                                                             % Scale the dx for accelerating the computations
dx       = scale_dx * dxups;
LR_xtrm  = double(solve(['0.5*(1+erf((x-',num2str(max(mean_xp_sim)),')/(sqrt(2)*sqrt(',num2str(max(var_xp_sim)),'))))-0.99999']));
LL_xtrm  = double(solve(['0.5*(1+erf((x-',num2str(max(mean_xp_sim)),')/(sqrt(2)*sqrt(',num2str(max(var_xp_sim)),'))))-0.00001']));
LR       = max(50*diameter,double(solve(['0.5*(1+erf((x-',num2str(max(mean_xp_sim)),')/(sqrt(2)*sqrt(',num2str(max(var_xp_sim)),'))))-0.999'])));
LL       = min(-50*diameter,double(solve(['0.5*(1+erf((x-',num2str(max(mean_xp_sim)),')/(sqrt(2)*sqrt(',num2str(max(var_xp_sim)),'))))-0.001']))); % LR and LL are arbitrary lengths. Warning: ensure that the particles are not arriving to x=LR neither x=LR. Check this by comparing the real and modeled meanpos.
x        = [fliplr(-dx:-dx:LL)  (0:dx:LR)];                                % Zero must be in x.

if LL_xtrm < min(x)
    x = [LL_xtrm x];
end
flag_xtrm = 0;
if max(x) < LR_xtrm
    x = [x LR_xtrm];
    flag_xtrm = 1;
end

% Insert in the x-vector some important distances (useful for computing BTCs)
DI = [-scale_dx*dxups : dxups : scale_dx*dxups];
for i=1:length(DI)
    if (x(1)<DI(i) && DI(i)<x(end))
        if isempty(find(x==DI(i)))
            x = sort([x DI(i)]);
        end
    end
end
t  = time_sim';


% Compute the concentration of particles, C(t,x)***************************
if flag_div == 1
    nd = max(1,round(max(t)/0.1));                                         % Number of divisions of the time domain for avoiding Matlab's memory errors.
else
    nd = 1;
end
stats = [];
hist_BTCs  = [];
    
% If no divisions in time domain.
if nd == 1
    C         = ADE(t,x);
    C(C<0)    = 0;                                                         % Remove negative C generated by a poor spatial discretization)
    stats     = compute_stats(C,x,stats);                                  % Compute the statistical moments of the particles position
    hist_BTCs = compute_btc(C,x,diameter,hist_BTCs,flag_xtrm);             % Compute the breakthrough curves (see Sund et. al, 2015)
    
    
% If divisions in time domain.    
else    
    nd = min(nd,fix(length(t)/3));                                         % Make sure that the ADE solver has at least 3 time-points at each division.
    lv = fix(length(t)/nd);                                                % Number of nodes at each time division.
    rs = length(t) - lv*nd;                                                % Excess of nodes to distribute between the divisions.
    b  = 0;
    for i=1:nd
        disp(['   Computing ',num2str(i),'/',num2str(nd), ' part of the ADE solver.'])
        islast = (i==nd);
        xtr    = (i<=rs);
        a      = b+1;
        b      = a + lv-1+xtr;
        
        t_aux = t(max(a-1,1):b);
        
        if i==1
            C = ADE(t_aux,x);
        else
            new_init_cond = @(x0) interp1(x,C(end,:),x0);
            C = ADE(t_aux,x,new_init_cond);                                % Give to the ADE-solver the last solution as an initial condition.
        end
        
        C      = C(2-(i==1):end,:);
        C(C<0) = 0;                                                        % Remove negative C generated by a poor spatial discretization)
        
        stats     = compute_stats(C,x,stats);                              % Compute the statistical moments of the particles position
        hist_BTCs = compute_btc(C,x,diameter,hist_BTCs,flag_xtrm);         % Compute the breakthrough curves (see Sund et. al, 2015)                        
    end
end


% Arrange the output variables
t           = t(:);
xp_avg_ADE  = stats(:,1);
xp_var_ADE  = stats(:,2);
xp_skew_ADE = stats(:,3);
xp_kur_ADE  = stats(:,4);
BTCs(:,1)   = hist_BTCs(:,1)/trapz(t,hist_BTCs(:,1));
BTCs(:,2)   = hist_BTCs(:,2)/trapz(t,hist_BTCs(:,2));
BTCs(:,3)   = hist_BTCs(:,3)/trapz(t,hist_BTCs(:,3));
BTCs(:,4)   = hist_BTCs(:,4)/trapz(t,hist_BTCs(:,4));
BTCs(:,5)   = hist_BTCs(:,5)/trapz(t,hist_BTCs(:,5));


return